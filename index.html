<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>抗压缩图像隐写 (盲水印)</title>
  <style>
    :root {
      color-scheme: light dark;
      --accent: #0ea5e9;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: "Inter", "SF Pro Display", system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at 18% 22%, rgba(14, 165, 233, 0.12), transparent 28%),
        radial-gradient(circle at 82% 10%, rgba(59, 130, 246, 0.12), transparent 26%),
        linear-gradient(180deg, #f8fafc, #eef2ff);
      min-height: 100vh;
      color: #0f172a;
    }

    header {
      padding: 32px 18px 14px;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-weight: 800;
      letter-spacing: -0.02em;
      font-size: clamp(28px, 4vw, 34px);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(14, 165, 233, 0.12);
      color: #075985;
      padding: 8px 12px;
      border-radius: 999px;
      font-weight: 700;
      font-size: 13px;
    }

    .lead {
      max-width: 780px;
      margin: 10px auto 0;
      color: #334155;
      line-height: 1.6;
    }

    main {
      max-width: 1160px;
      margin: 0 auto;
      padding: 24px;
      display: grid;
      gap: 16px;
    }

    @media (min-width: 980px) {
      main {
        grid-template-columns: 1.1fr 0.9fr;
        align-items: start;
      }
    }

    .card {
      background: rgba(255, 255, 255, 0.92);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 18px 50px rgba(15, 23, 42, 0.08);
      border: 1px solid #e2e8f0;
      backdrop-filter: blur(10px);
    }

    label {
      font-weight: 700;
      display: inline-block;
      margin-bottom: 6px;
      color: #0f172a;
    }

    input[type="file"],
    textarea,
    select,
    input[type="range"] {
      width: 100%;
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      padding: 10px 12px;
      font-size: 15px;
      background: #fff;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    textarea {
      min-height: 96px;
      resize: vertical;
    }

    input:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.28);
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }

    button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: 800;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
    }

    button.secondary {
      background: #0f172a;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(14, 165, 233, 0.35);
    }

    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      box-shadow: none;
    }

    canvas,
    img.preview {
      width: 100%;
      border-radius: 16px;
      box-shadow: inset 0 0 0 1px #e2e8f0;
      background: #f8fafc;
    }

    .meta {
      font-size: 13px;
      color: #475569;
      margin-top: 6px;
      line-height: 1.5;
    }

    .log {
      font-family: "SFMono-Regular", ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
      background: #0b1220;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 12px;
      min-height: 160px;
      white-space: pre-wrap;
      overflow: auto;
    }
  </style>
</head>
<body>
  <header>
    <div class="pill">GitHub Pages · DCT 盲水印 · 抗压缩/转码/截图</div>
    <h1>柔性隐写图片生成器</h1>
    <p class="lead">
      基于中频 DCT 量化 + 扩频重复嵌入的盲水印算法，无需原图即可提取。较 QR 水印更隐蔽，针对平台
      压缩、转码、缩略和截图仍能保持可读。仅用于嵌入一小段提示、口令或追踪标记。
    </p>
  </header>

  <main>
    <section class="card">
      <h2>生成隐写图</h2>
      <div>
        <label for="cover">选择封面图片</label>
        <input type="file" id="cover" accept="image/*" />
      </div>
      <div style="margin-top: 12px;">
        <label for="message">要隐藏的文本</label>
        <textarea id="message" placeholder="最多 180 字符，小段口令或提示" maxlength="180"></textarea>
      </div>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; margin-top: 12px;">
        <div>
          <label for="strength">嵌入强度</label>
          <input type="range" id="strength" min="8" max="26" value="14" />
          <div class="meta">值越大越抗压缩，但痕迹略明显。默认 14。</div>
        </div>
        <div>
          <label for="repeat">重复次数</label>
          <input type="range" id="repeat" min="4" max="16" value="8" />
          <div class="meta">重复越高越耐截屏/裁剪，但容量降低。</div>
        </div>
      </div>
      <div class="actions">
        <button id="encodeBtn">生成隐写图</button>
        <button id="downloadBtn" class="secondary" disabled>下载 PNG</button>
      </div>
      <div style="margin-top: 14px;">
        <canvas id="preview" aria-label="预览"></canvas>
        <div class="meta" id="meta"></div>
      </div>
    </section>

    <section class="card">
      <h2>提取隐藏信息</h2>
      <p class="meta">可以直接上传截图、压缩版或转码后的图片解码；无需原始封面。</p>
      <div>
        <label for="cipher">上传含隐写的图片</label>
        <input type="file" id="cipher" accept="image/*" />
      </div>
      <div class="actions">
        <button id="decodeBtn">读取隐藏信息</button>
      </div>
      <div class="log" id="log" aria-live="polite">等待操作...</div>
    </section>
  </main>

  <script>
    const coverInput = document.getElementById("cover");
    const cipherInput = document.getElementById("cipher");
    const messageInput = document.getElementById("message");
    const preview = document.getElementById("preview");
    const meta = document.getElementById("meta");
    const log = document.getElementById("log");
    const encodeBtn = document.getElementById("encodeBtn");
    const decodeBtn = document.getElementById("decodeBtn");
    const downloadBtn = document.getElementById("downloadBtn");
    const strengthInput = document.getElementById("strength");
    const repeatInput = document.getElementById("repeat");

    const BLOCK = 8;
    const COEFF_X = 3;
    const COEFF_Y = 2;

    const cosTable = (() => {
      const table = Array.from({ length: BLOCK }, () => Array(BLOCK).fill(0));
      for (let u = 0; u < BLOCK; u++) {
        for (let x = 0; x < BLOCK; x++) {
          table[u][x] = Math.cos(((2 * x + 1) * u * Math.PI) / (2 * BLOCK));
        }
      }
      return table;
    })();

    function alpha(v) {
      return v === 0 ? 1 / Math.sqrt(2) : 1;
    }

    function setLog(text) {
      log.textContent = text;
    }

    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    function clamp(v) {
      return Math.min(255, Math.max(0, v));
    }

    function rgbToYCbCr(r, g, b) {
      const y = 0.299 * r + 0.587 * g + 0.114 * b;
      const cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
      const cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;
      return [y, cb, cr];
    }

    function yCbCrToRgb(y, cb, cr) {
      const r = y + 1.402 * (cr - 128);
      const g = y - 0.344136 * (cb - 128) - 0.714136 * (cr - 128);
      const b = y + 1.772 * (cb - 128);
      return [clamp(r), clamp(g), clamp(b)];
    }

    function dctBlock(values) {
      const out = Array.from({ length: BLOCK }, () => Array(BLOCK).fill(0));
      for (let u = 0; u < BLOCK; u++) {
        for (let v = 0; v < BLOCK; v++) {
          let sum = 0;
          for (let x = 0; x < BLOCK; x++) {
            for (let y = 0; y < BLOCK; y++) {
              sum +=
                values[x][y] *
                cosTable[u][x] *
                cosTable[v][y];
            }
          }
          out[u][v] = (alpha(u) * alpha(v) * sum) / 4;
        }
      }
      return out;
    }

    function idctBlock(coeffs) {
      const out = Array.from({ length: BLOCK }, () => Array(BLOCK).fill(0));
      for (let x = 0; x < BLOCK; x++) {
        for (let y = 0; y < BLOCK; y++) {
          let sum = 0;
          for (let u = 0; u < BLOCK; u++) {
            for (let v = 0; v < BLOCK; v++) {
              sum +=
                alpha(u) *
                alpha(v) *
                coeffs[u][v] *
                cosTable[u][x] *
                cosTable[v][y];
            }
          }
          out[x][y] = sum / 4;
        }
      }
      return out;
    }

    function quantizeCoeff(value, bit, step) {
      const target = bit ? 0.75 : 0.25;
      const k = Math.round(value / step - target);
      return (k + target) * step;
    }

    function readBitFromCoeff(value, step) {
      const mod = ((value / step) % 1 + 1) % 1; // positive remainder
      const dist0 = Math.abs(mod - 0.25);
      const dist1 = Math.abs(mod - 0.75);
      return dist1 < dist0 ? 1 : 0;
    }

    function crc32(buf) {
      const table = (function () {
        let c;
        const t = [];
        for (let n = 0; n < 256; n++) {
          c = n;
          for (let k = 0; k < 8; k++) {
            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
          }
          t[n] = c >>> 0;
        }
        return t;
      })();
      let crc = -1;
      for (let i = 0; i < buf.length; i++) {
        crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xff];
      }
      return (crc ^ -1) >>> 0;
    }

    function bitsFromBytes(bytes) {
      const bits = [];
      for (const b of bytes) {
        for (let i = 7; i >= 0; i--) {
          bits.push((b >> i) & 1);
        }
      }
      return bits;
    }

    function bytesFromBits(bits) {
      const out = [];
      for (let i = 0; i + 7 < bits.length; i += 8) {
        let v = 0;
        for (let j = 0; j < 8; j++) {
          v = (v << 1) | bits[i + j];
        }
        out.push(v);
      }
      return new Uint8Array(out);
    }

    function majorityDecode(bits, repeat) {
      const recovered = [];
      for (let i = 0; i < bits.length; i += repeat) {
        const slice = bits.slice(i, i + repeat);
        const ones = slice.reduce((a, b) => a + b, 0);
        recovered.push(ones >= slice.length / 2 ? 1 : 0);
      }
      return recovered;
    }

    function createPayloadBits(text) {
      const encoder = new TextEncoder();
      const bytes = encoder.encode(text);
      if (bytes.length > 180) throw new Error("文本过长，最多 180 字节");
      const lenBytes = new Uint8Array([bytes.length >> 8, bytes.length & 0xff]);
      const checksum = crc32(bytes);
      const checksumBytes = new Uint8Array([
        (checksum >> 24) & 0xff,
        (checksum >> 16) & 0xff,
        (checksum >> 8) & 0xff,
        checksum & 0xff,
      ]);
      return bitsFromBytes(lenBytes).concat(bitsFromBytes(bytes), bitsFromBytes(checksumBytes));
    }

    function parsePayloadBits(bits) {
      if (bits.length < 16 + 32) return null;
      const lenBytes = bytesFromBits(bits.slice(0, 16));
      const len = (lenBytes[0] << 8) | lenBytes[1];
      const needed = (len + 2 + 4) * 8;
      if (bits.length < needed) return null;
      const dataBits = bits.slice(16, 16 + len * 8);
      const checksumBits = bits.slice(16 + len * 8, needed);
      const data = bytesFromBits(dataBits);
      const checksumBytes = bytesFromBits(checksumBits);
      const checksum =
        (checksumBytes[0] << 24) |
        (checksumBytes[1] << 16) |
        (checksumBytes[2] << 8) |
        checksumBytes[3];
      if (crc32(data) !== (checksum >>> 0)) return null;
      return new TextDecoder().decode(data);
    }

    function embedWatermark(imageData, bits, repeat, step) {
      const { width, height, data } = imageData;
      const y = new Float32Array(width * height);
      const cb = new Float32Array(width * height);
      const cr = new Float32Array(width * height);
      for (let i = 0, p = 0; i < data.length; i += 4, p++) {
        const [Y, Cb, Cr] = rgbToYCbCr(data[i], data[i + 1], data[i + 2]);
        y[p] = Y;
        cb[p] = Cb;
        cr[p] = Cr;
      }

      let bitIndex = 0;
      const totalBits = bits.length * repeat;
      const blocksX = Math.floor(width / BLOCK);
      const blocksY = Math.floor(height / BLOCK);
      const capacity = blocksX * blocksY;
      if (capacity < totalBits) {
        throw new Error(`图片容量不足，需要至少 ${Math.ceil(totalBits / capacity * 100)}% 更多像素`);
      }

      for (let by = 0; by < blocksY && bitIndex < totalBits; by++) {
        for (let bx = 0; bx < blocksX && bitIndex < totalBits; bx++) {
          const start = (by * BLOCK * width) + bx * BLOCK;
          const block = Array.from({ length: BLOCK }, () => Array(BLOCK).fill(0));
          for (let i = 0; i < BLOCK; i++) {
            for (let j = 0; j < BLOCK; j++) {
              block[i][j] = y[start + i * width + j];
            }
          }
          const coeffs = dctBlock(block);
          const bit = bits[Math.floor(bitIndex / repeat)];
          coeffs[COEFF_X][COEFF_Y] = quantizeCoeff(coeffs[COEFF_X][COEFF_Y], bit, step);
          const restored = idctBlock(coeffs);
          for (let i = 0; i < BLOCK; i++) {
            for (let j = 0; j < BLOCK; j++) {
              y[start + i * width + j] = restored[i][j];
            }
          }
          bitIndex++;
        }
      }

      for (let i = 0, p = 0; i < data.length; i += 4, p++) {
        const [r, g, b] = yCbCrToRgb(y[p], cb[p], cr[p]);
        data[i] = r;
        data[i + 1] = g;
        data[i + 2] = b;
      }
    }

    function extractBits(imageData, totalBits, repeat, step) {
      const { width, height, data } = imageData;
      const y = new Float32Array(width * height);
      for (let i = 0, p = 0; i < data.length; i += 4, p++) {
        y[p] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
      }
      const blocksX = Math.floor(width / BLOCK);
      const blocksY = Math.floor(height / BLOCK);
      const bits = [];
      for (let by = 0; by < blocksY && bits.length < totalBits; by++) {
        for (let bx = 0; bx < blocksX && bits.length < totalBits; bx++) {
          const start = (by * BLOCK * width) + bx * BLOCK;
          const block = Array.from({ length: BLOCK }, () => Array(BLOCK).fill(0));
          for (let i = 0; i < BLOCK; i++) {
            for (let j = 0; j < BLOCK; j++) {
              block[i][j] = y[start + i * width + j];
            }
          }
          const coeffs = dctBlock(block);
          bits.push(readBitFromCoeff(coeffs[COEFF_X][COEFF_Y], step));
        }
      }
      return bits.length ? majorityDecode(bits, repeat) : [];
    }

    function downloadCanvas(canvas, name) {
      canvas.toBlob(
        (blob) => {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = name;
          a.click();
          setTimeout(() => URL.revokeObjectURL(a.href), 5000);
        },
        "image/png",
        0.92
      );
    }

    async function renderStego() {
      const file = coverInput.files?.[0];
      const text = messageInput.value.trim();
      if (!file) return alert("请先选择封面图片");
      if (!text) return alert("请输入要隐藏的文本");
      encodeBtn.disabled = true;
      setLog("读取图片并准备嵌入...");
      try {
        const img = await loadImage(file);
        preview.width = img.width;
        preview.height = img.height;
        const ctx = preview.getContext("2d");
        ctx.drawImage(img, 0, 0, preview.width, preview.height);
        const imageData = ctx.getImageData(0, 0, preview.width, preview.height);
        const bits = createPayloadBits(text);
        const repeat = Number(repeatInput.value);
        const step = Number(strengthInput.value);
        const totalBits = bits.length * repeat;
        embedWatermark(imageData, bits, repeat, step / 10);
        ctx.putImageData(imageData, 0, 0);
        meta.textContent = `尺寸 ${img.width}×${img.height} · 容量 ${totalBits} bit · 使用 DCT(${COEFF_X},${COEFF_Y})`;
        downloadBtn.disabled = false;
        setLog("完成：盲水印已写入，可下载或右键保存。");
      } catch (err) {
        console.error(err);
        alert(err.message || "处理失败，请重试");
        setLog("生成失败，请检查图片尺寸或降低重复次数。");
      }
      encodeBtn.disabled = false;
    }

    async function decodeStego() {
      const file = cipherInput.files?.[0];
      if (!file) return alert("请上传含隐写的图片");
      decodeBtn.disabled = true;
      setLog("读取并分析图片...");
      try {
        const img = await loadImage(file);
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const headerBits = 16 + 180 * 8 + 32;
        const repeat = Number(repeatInput.value);
        const step = Number(strengthInput.value);
        const rawBits = extractBits(imageData, headerBits * repeat, repeat, step / 10);
        const payload = parsePayloadBits(rawBits);
        if (!payload) {
          setLog("未能可靠读出信息。尝试提高重复次数或使用更清晰的截图。");
        } else {
          setLog(`成功解码：\n${payload}`);
        }
      } catch (err) {
        console.error(err);
        setLog("读取失败，请重试。");
      }
      decodeBtn.disabled = false;
    }

    encodeBtn.addEventListener("click", renderStego);
    decodeBtn.addEventListener("click", decodeStego);
    downloadBtn.addEventListener("click", () => downloadCanvas(preview, "stego.png"));
  </script>
</body>
</html>
