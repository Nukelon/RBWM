<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>抗压缩图片隐写工具</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="preconnect" href="https://unpkg.com" />
  <style>
    :root {
      color-scheme: light dark;
      --accent: #4b7bec;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at 20% 20%, #f3f7ff 0%, #f9fbff 30%, transparent 40%),
        radial-gradient(circle at 80% 10%, #e7f0ff 0%, #eef4ff 25%, transparent 40%),
        var(--canvas-background, #f7f9fc);
      min-height: 100vh;
      color: #111827;
    }

    header {
      padding: 32px 16px 0;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-weight: 800;
      letter-spacing: -0.02em;
    }

    p.lead {
      margin: 8px auto 20px;
      max-width: 640px;
      color: #4b5563;
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 24px;
      box-sizing: border-box;
    }

    .card {
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08);
      border-radius: 18px;
      padding: 20px;
      margin-bottom: 18px;
      backdrop-filter: blur(8px);
    }

    .grid {
      display: grid;
      gap: 18px;
    }

    @media (min-width: 960px) {
      .grid {
        grid-template-columns: 1.1fr 0.9fr;
        align-items: start;
      }
    }

    label {
      font-weight: 600;
      display: inline-block;
      margin-bottom: 6px;
    }

    input[type="file"],
    input[type="text"],
    textarea,
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      background: #fff;
      font-size: 15px;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    textarea {
      resize: vertical;
      min-height: 96px;
    }

    input:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(75, 123, 236, 0.2);
    }

    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
    }

    button.secondary {
      background: #111827;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(75, 123, 236, 0.25);
    }

    canvas,
    img.preview {
      width: 100%;
      border-radius: 16px;
      box-shadow: inset 0 0 0 1px #e5e7eb;
      background: #f8fafc;
    }

    .preview-wrapper {
      position: relative;
      overflow: hidden;
    }

    .meta {
      font-size: 13px;
      color: #6b7280;
      margin-top: 6px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(75, 123, 236, 0.1);
      color: #1f2937;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
    }

    .log {
      font-family: "SFMono-Regular", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #0b1220;
      color: #e5e7eb;
      padding: 12px;
      border-radius: 12px;
      min-height: 140px;
      white-space: pre-wrap;
      overflow: auto;
    }
  </style>
</head>
<body>
  <header>
    <p class="pill">GitHub Pages 就绪 · 抗压缩、抗转码、可截图</p>
    <h1>隐写图片生成器</h1>
    <p class="lead">
      输入图片和要隐藏的文本，工具会利用高容错 QR 编码 + 软光滤镜水印方式，将文字隐写到整张图片的亮度细节中。
      经过压缩、转码、甚至截图后仍可解出信息。
    </p>
  </header>

  <main class="grid">
    <section class="card">
      <h2>生成隐写图</h2>
      <div>
        <label for="cover">选择封面图片</label>
        <input type="file" id="cover" accept="image/*" />
      </div>
      <div style="margin-top: 12px;">
        <label for="message">要隐藏的文本</label>
        <textarea id="message" placeholder="一句话、一段提醒或加密 token" maxlength="280"></textarea>
      </div>
      <div style="margin-top: 12px; display: grid; gap: 12px; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));">
        <div>
          <label for="ecc">纠错强度 (QR ECC)</label>
          <select id="ecc">
            <option value="L">L (7%)</option>
            <option value="M">M (15%)</option>
            <option value="Q">Q (25%)</option>
            <option value="H" selected>H (30%)</option>
          </select>
        </div>
        <div>
          <label for="strength">嵌入强度</label>
          <input type="range" min="2" max="18" value="8" id="strength" />
          <div class="meta">强度越高越易识别，但肉眼越易察觉。</div>
        </div>
      </div>
      <div class="actions">
        <button id="encodeBtn">生成隐写图</button>
        <button id="downloadBtn" class="secondary" disabled>下载 PNG</button>
      </div>
      <div class="preview-wrapper" style="margin-top: 14px;">
        <canvas id="preview" aria-label="预览"></canvas>
        <div class="meta" id="meta"></div>
      </div>
    </section>

    <section class="card">
      <h2>解码隐写图</h2>
      <p class="meta">使用截图、压缩版或转码后的图片都可以直接上传解码。</p>
      <div>
        <label for="cipher">上传含隐写的图片</label>
        <input type="file" id="cipher" accept="image/*" />
      </div>
      <div class="actions">
        <button id="decodeBtn">读取隐藏信息</button>
      </div>
      <div class="log" id="log" aria-live="polite">等待操作...</div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
  <script>
    const coverInput = document.getElementById("cover");
    const cipherInput = document.getElementById("cipher");
    const messageInput = document.getElementById("message");
    const preview = document.getElementById("preview");
    const meta = document.getElementById("meta");
    const log = document.getElementById("log");
    const encodeBtn = document.getElementById("encodeBtn");
    const decodeBtn = document.getElementById("decodeBtn");
    const downloadBtn = document.getElementById("downloadBtn");
    const eccSelect = document.getElementById("ecc");
    const strengthInput = document.getElementById("strength");

    const ctx = preview.getContext("2d");

    const setLog = (text) => {
      log.textContent = text;
    };

    const loadImageFromFile = (file) =>
      new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });

    function createQrCanvas(text, ecc) {
      const qr = qrcode(0, ecc);
      qr.addData(text);
      qr.make();
      const count = qr.getModuleCount();
      const cell = 6;
      const margin = 4;
      const size = count * cell + margin * 2;
      const qrCanvas = document.createElement("canvas");
      qrCanvas.width = qrCanvas.height = size;
      const qCtx = qrCanvas.getContext("2d");
      qCtx.fillStyle = "#fff";
      qCtx.fillRect(0, 0, size, size);
      qCtx.fillStyle = "#000";
      for (let r = 0; r < count; r++) {
        for (let c = 0; c < count; c++) {
          if (qr.isDark(r, c)) {
            qCtx.fillRect(margin + c * cell, margin + r * cell, cell, cell);
          }
        }
      }
      return qrCanvas;
    }

    function tileOverlay(baseCtx, overlay, alpha = 0.08) {
      const { width, height } = baseCtx.canvas;
      const padding = 24;
      baseCtx.save();
      baseCtx.globalAlpha = alpha;
      baseCtx.globalCompositeOperation = "soft-light";
      for (let y = 0; y < height + overlay.height; y += overlay.height + padding) {
        for (let x = 0; x < width + overlay.width; x += overlay.width + padding) {
          baseCtx.drawImage(overlay, x - overlay.width / 3, y - overlay.height / 3);
        }
      }
      baseCtx.restore();
    }

    function enhanceForDecode(imageData) {
      const data = imageData.data;
      let min = 255;
      let max = 0;
      const gray = new Uint8ClampedArray(imageData.width * imageData.height);
      for (let i = 0, g = 0; i < data.length; i += 4, g++) {
        const v = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
        min = Math.min(min, v);
        max = Math.max(max, v);
        gray[g] = v;
      }
      const range = Math.max(30, max - min);
      for (let i = 0; i < gray.length; i++) {
        let v = ((gray[i] - min) / range) * 255;
        v = Math.max(0, Math.min(255, v * 1.15));
        gray[i] = v;
      }
      return gray;
    }

    function decodeRegions(img) {
      const c = document.createElement("canvas");
      c.width = img.width;
      c.height = img.height;
      const cctx = c.getContext("2d");
      cctx.drawImage(img, 0, 0, c.width, c.height);
      const regions = [];
      const midX = c.width / 2;
      const midY = c.height / 2;
      const w = Math.floor(c.width * 0.7);
      const h = Math.floor(c.height * 0.7);
      const quads = [
        [midX - w / 2, midY - h / 2],
        [0, 0],
        [c.width - w, 0],
        [0, c.height - h],
        [c.width - w, c.height - h],
      ];
      for (const [x, y] of quads) {
        regions.push(cctx.getImageData(x, y, w, h));
      }
      return regions;
    }

    function downloadCanvas(canvas, name) {
      canvas.toBlob((blob) => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = name;
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 5000);
      }, "image/png", 0.92);
    }

    async function renderStego() {
      const file = coverInput.files?.[0];
      const text = messageInput.value.trim();
      if (!file) return alert("请先选择封面图片");
      if (!text) return alert("请输入要隐藏的文本");
      encodeBtn.disabled = true;
      setLog("正在生成 QR 水印...");
      const img = await loadImageFromFile(file);
      preview.width = img.width;
      preview.height = img.height;
      ctx.drawImage(img, 0, 0, preview.width, preview.height);
      const overlay = createQrCanvas(text, eccSelect.value);
      const strength = Number(strengthInput.value) / 100 * 1.6 + 0.05;
      tileOverlay(ctx, overlay, strength);
      meta.textContent = `尺寸 ${img.width}×${img.height} · 水印重复覆盖`; 
      downloadBtn.disabled = false;
      setLog("完成：隐写图已生成，可下载或右键保存。");
      encodeBtn.disabled = false;
    }

    async function decodeStego() {
      const file = cipherInput.files?.[0];
      if (!file) return alert("请上传含隐写的图片");
      decodeBtn.disabled = true;
      setLog("读取图片...");
      try {
        const img = await loadImageFromFile(file);
        const regions = decodeRegions(img);
        for (const region of regions) {
          const gray = enhanceForDecode(region);
          const code = jsQR(gray, region.width, region.height, {
            inversionAttempts: "dontInvert",
          });
          if (code?.data) {
            setLog(`成功解码：\n${code.data}`);
            decodeBtn.disabled = false;
            return;
          }
        }
        setLog("未能读出信息。尝试更高的嵌入强度、保持截图更清晰，或上传完整图片。");
      } catch (err) {
        console.error(err);
        setLog("读取失败，请重试。");
      }
      decodeBtn.disabled = false;
    }

    encodeBtn.addEventListener("click", renderStego);
    decodeBtn.addEventListener("click", decodeStego);
    downloadBtn.addEventListener("click", () => downloadCanvas(preview, "stego.png"));
  </script>
</body>
</html>
